<?php

declare(strict_types=1);

namespace Fp4\PHP\Option;

use Closure;
use Fp4\PHP\Bindable;
use Fp4\PHP\PsalmIntegration\Module\Option\BindableCompressor;
use Fp4\PHP\PsalmIntegration\Module\Option\BindFunctionStorageProvider;
use Fp4\PHP\PsalmIntegration\Module\Option\LetFunctionStorageProvider;

/**
 * @return Option<Bindable>
 */
function bindable(): Option
{
    return some(new Bindable());
}

/**
 * Signature will be generated by {@see BindFunctionStorageProvider} plugin hook.
 * Return type will be post processed by {@see BindableCompressor} plugin hook.
 *
 * @param Closure(Bindable): Option ...$params
 * @return Closure(Option<Bindable>): Option<Bindable>
 */
function bind(Closure ...$params): Closure
{
    return function(Option $context) use ($params) {
        if (isNone($context)) {
            return none();
        }

        $bindable = $context->value;

        foreach ($params as $key => $param) {
            $result = $param($bindable);

            if (isNone($result)) {
                return none();
            }

            $bindable = $bindable->with((string) $key, $result->value);
        }

        return some($bindable);
    };
}

/**
 * Signature will be generated by {@see LetFunctionStorageProvider} plugin hook.
 * Return type will be post processed by {@see BindableCompressor} plugin hook.
 *
 * @param Closure(Bindable): mixed ...$params
 * @return Closure(Option<Bindable>): Option<Bindable>
 */
function let(Closure ...$params): Closure
{
    return function(Option $context) use ($params) {
        if (isNone($context)) {
            return none();
        }

        $bindable = $context->value;

        foreach ($params as $key => $param) {
            $bindable = $bindable->with((string) $key, $param($bindable));
        }

        return some($bindable);
    };
}
